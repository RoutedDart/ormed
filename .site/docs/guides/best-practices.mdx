---
sidebar_position: 2
---

# Best Practices

Recommended patterns, common pitfalls, and optimization strategies for using Ormed effectively.

## Prerequisites

- [Quick Start](../getting-started/quick-start)
- [Query Builder](../queries/query-builder)

## What You’ll Learn

- Performance-safe query and relation patterns
- Common schema and model design pitfalls to avoid
- Team-level conventions that keep Ormed code maintainable

## Step Outcome

By the end of this page, you should be able to:

- Identify high-risk query/model patterns early in review
- Apply consistent team conventions for performance and safety
- Convert checklist items into lint/test guardrails

## Query Optimization

### Avoid N+1 Queries

**❌ Bad:** Lazy loading in loops

```dart file=../../examples/lib/best_practices/best_practices.dart#n-plus-one-bad
```

**✅ Good:** Eager load relations upfront

```dart file=../../examples/lib/best_practices/best_practices.dart#n-plus-one-good
```

### Use Aggregate Loaders

**❌ Bad:** Loading full collections to count

```dart file=../../examples/lib/best_practices/best_practices.dart#aggregate-bad
```

**✅ Good:** Use aggregate loaders

```dart file=../../examples/lib/best_practices/best_practices.dart#aggregate-good
```

### Select Only What You Need

**❌ Bad:** Selecting all columns

```dart file=../../examples/lib/best_practices/best_practices.dart#select-bad
```

**✅ Good:** Use `pluck()` for single columns

```dart file=../../examples/lib/best_practices/best_practices.dart#select-good
```

### Use Pagination

```dart file=../../examples/lib/best_practices/best_practices.dart#pagination
```

Treat unbounded reads as an explicit exception, not a default pattern.

### Index Frequently Queried Columns

```dart file=../../examples/lib/best_practices/best_practices.dart#indexes
```

## Relation Loading Strategies

### When to Use Eager Loading

✅ Use when you **know** you'll need the relations:
- List views showing related data
- APIs returning nested resources
- Reports and dashboards

```dart file=../../examples/lib/best_practices/best_practices.dart#when-eager
```

### When to Use Lazy Loading

✅ Use when relations are **conditionally** needed:
- Detail views with permission-based data
- Optional expansions based on request parameters

```dart file=../../examples/lib/best_practices/best_practices.dart#when-lazy
```

### Use loadMissing for Hybrid Scenarios

```dart file=../../examples/lib/best_practices/best_practices.dart#load-missing
```

### Prevent Lazy Loading in Development

```dart file=../../examples/lib/best_practices/best_practices.dart#prevent-lazy
```

## Model Design

### Extend Model for Full Features

```dart file=../../examples/lib/best_practices/best_practices.dart#extend-model
```

Benefits:
- Lazy loading: `await user.load(['posts'])`
- Relation mutations: `user.associate('role', role)`
- Persistence: `await user.save()`
- Attributes: `user.getAttribute('computed_value')`

### Use Immutable Models

```dart file=../../examples/lib/best_practices/best_practices.dart#immutable-model
```

Benefits: Thread-safe, predictable, easy to test.

### Use Soft Deletes Wisely

```dart file=../../examples/lib/best_practices/best_practices.dart#soft-deletes-wise
```

## Error Handling

### Use Typed Exceptions

```dart file=../../examples/lib/best_practices/best_practices.dart#error-typed-exceptions

```

### Validate Before Save

Define validation rules on your model:

```dart file=../../examples/lib/best_practices/best_practices.dart#error-validate-before-save-model
```

Call validation before persistence:

```dart file=../../examples/lib/best_practices/best_practices.dart#error-validate-before-save-usage
```

### Use Transactions for Critical Operations

```dart file=../../examples/lib/best_practices/best_practices.dart#error-transactions

```

## Testing

### Use In-Memory Databases

```dart file=../../examples/lib/best_practices/best_practices.dart#testing-in-memory

```

### Use Factories for Test Data

```dart file=../../examples/lib/best_practices/best_practices.dart#testing-factories

```

## Security

### Never Use Raw User Input

**❌ Bad:** SQL injection risk

```dart file=../../examples/lib/best_practices/best_practices.dart#security-sql-injection-bad

```

**✅ Good:** Parameterized queries

```dart file=../../examples/lib/best_practices/best_practices.dart#security-sql-injection-good

```

### Validate Relations Before Mutations

```dart file=../../examples/lib/best_practices/best_practices.dart#security-validate-relations

```

### Use Scopes for Multi-Tenancy

```dart file=../../examples/lib/best_practices/best_practices.dart#security-scopes-multitenancy

```

### Limit Exposed Fields

Create DTOs for API responses:

```dart file=../../examples/lib/best_practices/best_practices.dart#security-dto

```

## Summary Checklist

### Query Performance
- [ ] Use eager loading instead of lazy loading in loops
- [ ] Use aggregate loaders instead of loading full collections
- [ ] Add database indexes for frequently queried columns
- [ ] Use pagination for large result sets

### Model Design
- [ ] Extend `Model<T>` for full feature support
- [ ] Use immutable models
- [ ] Add validation methods
- [ ] Use soft deletes only when needed

### Error Handling
- [ ] Catch specific exceptions
- [ ] Use transactions for critical operations
- [ ] Validate data before persistence

### Security
- [ ] Never concatenate user input in queries
- [ ] Validate relations before mutations
- [ ] Use scopes for multi-tenancy
- [ ] Create DTOs for API responses

## Verify Team Adoption

1. Add review checklist items from this page to PR templates.
2. Add analyzer/plugin rules for common anti-patterns.
3. Add integration tests for query cardinality and relation loading paths.

## Read This Next

- [Testing](./testing)
- [Observability](./observability)
- [Examples & Recipes](./examples)
