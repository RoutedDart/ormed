---
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Observability

The ORM exposes structured hooks for every query and mutation so you can ship metrics, traces, and logs without patching driver code.

## Prerequisites

- [Query Builder](../queries/query-builder)
- [CLI Overview](../cli/overview)

## What You’ll Learn

- How to capture and inspect structured query logs
- How to stream ORM events to metrics/tracing systems
- How to debug slow or failing operations with runtime hooks

## Step Outcome

By the end of this page, you should be able to:

- Capture query/mutation telemetry without modifying driver code
- Route ORM events to your logging/metrics/tracing stack
- Investigate slow/failing database operations with concrete runtime data

## Query Logging

The simplest way to observe queries is via the built-in query log on `OrmConnection` or `DataSource`:

<Tabs groupId="observability-query-logging" defaultValue="notes">
<TabItem value="notes" label="Notes">

- Use this for development or simple production diagnostics.
- Disable parameter capture for sensitive fields by setting `includeParameters: false`.
- When enabled, transaction boundaries (BEGIN/COMMIT/ROLLBACK/SAVEPOINT) are also logged as `type: transaction`.

</TabItem>
<TabItem value="code" label="Code">

```dart file=../../examples/lib/observability/observability.dart#query-logging
```

</TabItem>
</Tabs>

### API Reference

| Method | Description |
| --- | --- |
| `enableQueryLog({includeParameters, clear})` | Enables logging; `includeParameters` controls whether bind values are captured (default: true); `clear` resets the log (default: true) |
| `disableQueryLog({clear})` | Disables logging; optionally clears entries |
| `clearQueryLog()` | Removes all accumulated entries |
| `queryLog` | Returns an immutable list of `QueryLogEntry` objects |
| `loggingQueries` | Returns `true` when logging is active |

### QueryLogEntry Fields

| Field | Description |
| --- | --- |
| `type` | `'query'`, `'mutation'`, or `'transaction'` |
| `sql` | The SQL statement with bindings interpolated |
| `preview` | Full `StatementPreview` with raw SQL and parameter lists |
| `duration` | Execution time |
| `success` | `true` if no error was thrown |
| `model` | Model name (e.g., `'User'`) when applicable |
| `table` | Table name (e.g., `'users'`) when applicable |
| `rowCount` | Rows returned or affected |
| `error` | Exception object when `success` is `false` |
| `parameters` | Bind values (empty when `includeParameters` is `false`) |
| `toMap()` | JSON-serializable representation |

Start with query logs first, then add event hooks and tracing once baseline visibility is in place.

### Listening to Log Events

Use `onQueryLogged` to receive entries as they are recorded:

```dart file=../../examples/lib/observability/observability.dart#on-query-logged

```

## Query & Mutation Events

Register listeners on the `QueryContext`:

```dart file=../../examples/lib/observability/observability.dart#query-events
```

### QueryEvent Fields

| Field | Description |
| --- | --- |
| `plan` | `QueryPlan` executed against the driver |
| `preview` | `StatementPreview` with SQL text |
| `duration` | Wall-clock `Duration` for the execution |
| `rows` | Number of rows returned |
| `error` / `stackTrace` | Populated when the driver threw |
| `succeeded` | `true` when no error occurred |

### MutationEvent Fields

| Field | Description |
| --- | --- |
| `plan` | `MutationPlan` (operation, rows, returning flag) |
| `preview` | SQL preview for the mutation |
| `duration` | Execution time |
| `affectedRows` | Driver-reported row count |
| `error` / `stackTrace` | Failure context |
| `succeeded` | Indicates success |

## StructuredQueryLogger

Attach a structured logger for JSON-friendly output:

```dart file=../../examples/lib/observability/observability.dart#structured-logger
```

Each entry contains:

```json
{
  "type": "query",
  "timestamp": "2025-01-01T12:00:00.000Z",
  "model": "User",
  "table": "users",
  "sql": "SELECT \"id\" FROM \"users\" WHERE \"email\" = ?",
  "parameters": ["alice@example.com"],
  "duration_ms": 1.23,
  "success": true,
  "env": "prod"
}
```

For failed queries, the logger adds `error_type`, `error_message`, and (optionally) `stack_trace`.

### Printing Helper

For development or when piping logs to stdout:

```dart file=../../examples/lib/observability/observability.dart#printing-helper
```

## SQL Preview Without Execution

Use `Query.toSql()` to inspect queries before running them:

```dart file=../../examples/lib/observability/observability.dart#sql-preview
```

Mutation previews are available via repository helpers (`previewInsert`, `previewUpdateMany`, etc.) and `context.describeMutation()`.

## Connection Instrumentation

`OrmConnection` provides additional hooks for fine-grained control.

### Before Hooks

Intercept queries or mutations before they execute:

```dart file=../../examples/lib/observability/observability.dart#before-hooks
```

### beforeExecuting

Called just before SQL is sent to the driver, with full statement context:

```dart file=../../examples/lib/observability/observability.dart#before-executing

```

### Slow Query Detection

```dart file=../../examples/lib/observability/observability.dart#slow-query-detection

```

### Pretend Mode

Capture SQL without executing against the database:

```dart file=../../examples/lib/observability/observability.dart#pretend-mode

```

During pretend mode, `connection.pretending` returns `true`.

## Integration with Tracing

Use event hooks to create tracing spans:

<Tabs groupId="observability-tracing" defaultValue="notes">
<TabItem value="notes" label="Notes">

- Use `event.preview.sql` / `event.duration` to label spans consistently.
- Prefer a low-cardinality span name (e.g. `db.query`) and put SQL in attributes.

</TabItem>
<TabItem value="code" label="Code">

```dart file=../../examples/lib/observability/observability.dart#tracing-integration

```

</TabItem>
</Tabs>

## Metrics Integration

Send query metrics to your monitoring service:

```dart file=../../examples/lib/observability/observability.dart#metrics-integration

```

## Best Practices

- **Attach early** – Add event listeners as soon as the `QueryContext` is created to capture migrations, seed data, and runtime queries.

- **Protect secrets** – Disable `includeParameters` or scrub entries inside `onLog` for columns that may contain PII.

- **Correlate with tracing** – Use `onQuery`/`onMutation` to start tracing spans using the SQL preview and duration data.

- **Monitor slow queries** – Register a listener that warns when `event.duration` exceeds your SLO.

```dart file=../../examples/lib/observability/observability.dart#slow-query-monitoring

```

## Verify Observability Setup

1. Enable query logging and run one read + one write query.
2. Confirm log entries include SQL + duration + success/failure.
3. Trigger a known failure and confirm error fields are emitted.

## Read This Next

- [Best Practices](./best-practices)
- [Testing](./testing)
- [Multi-Database Support](./multi-database)
