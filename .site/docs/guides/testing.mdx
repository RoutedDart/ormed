---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Testing

Ormed provides comprehensive testing facilities for isolated, reliable database tests.

To get started, import the testing utilities:

```dart
import 'package:ormed/testing.dart';
```

## Isolation Strategies

Ormed supports several strategies for isolating database state between tests. You can configure the strategy in `setUpOrmed`.

### `migrateWithTransactions` (Default)
The fastest strategy. It runs migrations once per group and wraps each test in a transaction that is rolled back after the test completes.

### `truncate`
Runs migrations once per group and truncates all tables after each test. This is useful for drivers that don't support nested transactions or when you need to test transaction behavior itself.

### `recreate`
The most thorough but slowest strategy. It drops and recreates the entire schema/database for every test.

## Group vs Test Isolation

Ormed provides two primary functions for defining tests: `ormedGroup` and `ormedTest`.

### `ormedGroup`
Use `ormedGroup` to group related tests that share a common database setup. Every group gets its own unique database for true concurrency.

```dart
ormedGroup('User Management', (ds) {
  // This database is provisioned once for the group
});
```

### `ormedTest`
Use `ormedTest` for individual test cases. 
- When used **inside** an `ormedGroup`, it inherits the group's `DataSource` and isolation strategy.
- When used **standalone**, it creates a completely fresh database for that specific test.

```dart
ormedTest('can create user', (ds) async {
  final user = await ds.repo<User>().insert(User(name: 'Alice'));
  expect(user.id, isNotNull);
});
```

## DataSource Injection
Both `ormedGroup` and `ormedTest` inject a `DataSource` instance into their callbacks. **Always use this injected instance** to ensure your tests run against the isolated test database rather than a global or shared instance.

### Accessing the Current DataSource
If you need to access the `DataSource` within standard `setUp` or `tearDown` blocks, you can use the `currentTestDataSource` getter:

```dart
setUp(() {
  final ds = currentTestDataSource;
  // Perform setup using the isolated data source
});
```

## Core Setup
The `setUpOrmed` function is the entry point for configuring your test environment. It should be called once in your `main()` function before defining any tests.

<Tabs groupId="testing-core" defaultValue="basic">
  <TabItem value="basic" label="Basic">

Create a fresh DataSource for each test suite.

```dart file=../../examples/lib/testing/testing.dart#testing-basic-setup
```

  </TabItem>
  <TabItem value="in-memory" label="SQLite in-memory">

Fast, isolated tests.

```dart file=../../examples/lib/testing/testing.dart#testing-in-memory
```

  </TabItem>
  <TabItem value="seeders" label="Seeders">

Define a seeder class for consistent test data.

```dart file=../../examples/lib/testing/testing.dart#testing-seeder
```

  </TabItem>
  <TabItem value="real-db" label="Real DB">

Integration tests with SQLite on disk.

```dart file=../../examples/lib/testing/testing.dart#testing-real-db
```

  </TabItem>
  <TabItem value="migration-harness" label="Migrations">

Migration-aware test harness.

```dart file=../../examples/lib/testing/testing.dart#testing-migration-harness
```

  </TabItem>
</Tabs>

## Static Helpers in Tests

Set a default DataSource for `Model` static helpers:

```dart file=../../examples/lib/testing/testing.dart#testing-static-helpers
```

## Testing Relations

Ensure all related entities are registered:

```dart file=../../examples/lib/testing/testing.dart#testing-relations
```

## Parallel Testing

For parallel test execution without conflicts:

```dart file=../../examples/lib/testing/testing.dart#testing-parallel
```

## Best Practices

### Use SQLite In-Memory for Unit Tests

```dart file=../../examples/lib/testing/testing.dart#testing-best-practices-in-memory
```

### Use Real Databases for Integration Tests

```dart file=../../examples/lib/testing/testing.dart#testing-best-practices-real-db
```

### Keep Tests Isolated

```dart file=../../examples/lib/testing/testing.dart#testing-keep-isolated
```

### Use Factories for Test Data

```dart file=../../examples/lib/testing/testing.dart#testing-factories
```

### Test Both Success and Failure Cases

```dart file=../../examples/lib/testing/testing.dart#testing-success-failure
```

## Advanced: TestDatabaseManager
`TestDatabaseManager` is the underlying engine that manages the lifecycle of test databases. While `ormedGroup` and `ormedTest` are the preferred high-level APIs, you can access the manager via the `testDatabaseManager` getter if you need lower-level control, such as manually seeding data or checking migration status.

```dart
final manager = testDatabaseManager;
await manager?.seed([MySeeder()], ds);
```

## Example Test Suite

<Tabs groupId="testing-suite" defaultValue="setup">
  <TabItem value="setup" label="Setup">

```dart file=../../examples/lib/testing/testing.dart#testing-example-suite-setup
```

  </TabItem>
  <TabItem value="tests" label="Tests">

```dart file=../../examples/lib/testing/testing.dart#testing-example-suite-tests
```

  </TabItem>
  <TabItem value="teardown" label="Tear Down">

```dart file=../../examples/lib/testing/testing.dart#testing-example-suite-teardown
```

  </TabItem>
</Tabs>
