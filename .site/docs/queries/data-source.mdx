---
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# DataSource

The `DataSource` class provides a modern, declarative API for configuring and using the ORM. It bundles driver configuration, entity registration, and connection management into a single interface.

## Prerequisites

- [Configuration](../getting-started/configuration)
- [Drivers Overview](../drivers/overview)

## What You’ll Learn

- How `DataSourceOptions` shape runtime behavior
- How initialization and default connection selection work
- How to choose between generated helpers and manual datasource composition

## Step Outcome

By the end of this page, you should be able to:

- Build a `DataSource` from generated options or manual options
- Initialize and dispose connections safely
- Route queries to default or named connections intentionally

## Minimal Lifecycle (Always)

1. Construct `DataSource` with options.
2. Call `await ds.init()` once.
3. Run query/repository operations.
4. Call `await ds.dispose()` on shutdown/tests.

## Overview

```dart file=../../examples/lib/datasource.dart#datasource-overview
```

## DataSourceOptions

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `driver` | `DriverAdapter` | **required** | The database driver adapter |
| `entities` | `List<ModelDefinition>` | `[]` | Models to register. Provide this or `registry`. |
| `registry` | `ModelRegistry?` | `null` | Generated registry (includes type aliases). If provided and `entities` is empty, models are taken from the registry. |
| `name` | `String` | `'default'` | Logical name for the connection |
| `database` | `String?` | `null` | Database/catalog identifier for observability |
| `tablePrefix` | `String` | `''` | Prefix applied to unqualified table names (queries, joins, pivots, and schema operations). Schema-qualified names are not prefixed. |
| `defaultSchema` | `String?` | `null` | Default schema for ad-hoc queries |
| `codecs` | `Map<String, ValueCodec>` | `{}` | Custom value codecs to register |
| `logging` | `bool` | `false` | Enable query logging |
| `logger` | `contextual.Logger?` | `null` | Optional contextual logger for default query logging (used only when `logging` is true) |

### Example Configuration (with generated registry)

```dart file=../../examples/lib/datasource.dart#datasource-options
```

## Initialization

Always call `init()` before using the data source:

```dart file=../../examples/lib/datasource.dart#datasource-init
```

The `init()` method:
- Is idempotent—calling it multiple times has no effect
- Automatically registers the DataSource with `ConnectionManager`
- Automatically sets it as default if it's the first DataSource initialized

If you use static model helpers (`Users.query()`), make sure a default datasource has been initialized or explicitly set.

## Using Static Model Helpers

Once initialized, the first `DataSource` automatically becomes the default. This enables using generated model helper classes (like `Users` / `Posts`) without threading a `DataSource` everywhere.

```dart file=../../examples/lib/datasource.dart#datasource-static-helpers
```

### ConnectionManager + Resolver Binding

Static helpers resolve connections in this order:
1. A custom resolver set via `Model.bindConnectionResolver(...)`.
2. The default `ConnectionManager` registration (set by `init()` or `setAsDefault()`).

If you need complete control (multi-tenant, sharded, per-request routing), bind your own resolver:

```dart
Model.bindConnectionResolver(
  resolveConnection: (_) => myQueryContext,
  connectionManager: ConnectionManager.instance,
  defaultConnection: 'primary',
);
```

To clear static bindings (tests or teardown):

```dart
Model.unbindConnectionResolver();
ConnectionManager.instance.clearDefault();
DataSource.clearDefault();
```

## Querying Data

Use `query<T>()` to create a typed query builder:

```dart file=../../examples/lib/datasource.dart#datasource-querying
```

## Repository Operations

Use `repo<T>()` for CRUD operations:

```dart file=../../examples/lib/datasource.dart#datasource-repository
```

## Transactions

Execute multiple operations atomically:

```dart file=../../examples/lib/datasource.dart#datasource-transactions
```

Use transactions for any sequence where partial success would leave inconsistent state.

## Ad-hoc Table Queries

Query tables without a model definition:

```dart file=../../examples/lib/datasource.dart#datasource-adhoc
```

## Query Logging & Debugging

<Tabs groupId="datasource-logging" defaultValue="basic">
  <TabItem value="basic" label="Basic">

```dart file=../../examples/lib/datasource.dart#datasource-logging
```

  </TabItem>
  <TabItem value="options" label="Options">

```dart file=../../examples/lib/datasource.dart#datasource-logging-options
```

  </TabItem>
</Tabs>

### Access Query Log

```dart file=../../examples/lib/datasource.dart#datasource-query-log-access
```

### Contextual Logger

```dart file=../../examples/lib/datasource.dart#datasource-logging-logger
```

### Pretend Mode

Preview SQL without executing:

```dart file=../../examples/lib/datasource.dart#datasource-pretend-mode
```

### Execution Hooks

```dart file=../../examples/lib/datasource.dart#datasource-execution-hooks
```

## Multiple DataSources

Create separate data sources for different databases:

<Tabs groupId="datasource-multiple" defaultValue="notes">
  <TabItem value="notes" label="Notes">

Use multiple data sources when you need separate databases (tenants, analytics, read/write split, etc.). Keep them named and dispose them on shutdown.

  </TabItem>
  <TabItem value="code" label="Code">

<Tabs groupId="datasource-multiple-code" defaultValue="setup">
  <TabItem value="setup" label="Setup">

Define and initialize two `DataSource`s (each has its own connection).

```dart file=../../examples/lib/datasource.dart#datasource-multiple-setup
```

  </TabItem>
  <TabItem value="default" label="Default">

Optionally set a default connection for static helpers:

```dart file=../../examples/lib/datasource.dart#datasource-multiple-default
```

  </TabItem>
  <TabItem value="query" label="Query">

Query through the `DataSource` you want (or pass `connection:` to static helpers).

```dart file=../../examples/lib/datasource.dart#datasource-multiple-query
```

  </TabItem>
</Tabs>

  </TabItem>
</Tabs>

## Common Production Pattern

- Keep one primary write datasource.
- Add read/analytics datasource only when needed.
- Name connections explicitly (`primary`, `analytics`, tenant IDs).
- Avoid implicit switching in shared utility code.

## Lifecycle Management

```dart file=../../examples/lib/datasource.dart#datasource-lifecycle
```

Disposing a default `DataSource` unregisters it from `ConnectionManager` and clears static helper bindings, so subsequent static calls require a new default to be set.

### Access Underlying Components

```dart file=../../examples/lib/datasource.dart#datasource-underlying
```

## Custom Codecs

```dart file=../../examples/lib/datasource.dart#datasource-custom-codecs
```

## Read This Next

- [Query Builder](./query-builder)
- [Repository](./repository)
- [Configuration](../getting-started/configuration)
- [Multi-Database Support](../guides/multi-database)
