---
sidebar_position: 3
---

# Loading Relations

Ormed supports eager loading, lazy loading, and aggregate relation loading so you can control query count and response shape explicitly.

## Prerequisites

- [Relationships](../models/relationships)
- [Query Builder](./query-builder)

## What Youâ€™ll Learn

- How to eager-load and lazy-load relation graphs
- How to avoid N+1 query patterns
- How nested relations and constraints are expressed

## Step Outcome

By the end of this page, you should be able to load relation trees intentionally, detect accidental lazy loads, and use aggregate relation helpers.

:::note Snippet context
- Snippets focus on relation APIs and omit full setup.
- Unless shown otherwise, assume you already have a `DataSource` named `dataSource` and your relations were generated via `build_runner`.
:::

## 1. Eager Load First

Load relations with the main query to avoid per-row follow-up calls.

### Basic Eager Loading

```dart file=../../examples/lib/relations/loading.dart#eager-basic
```

### Multiple Relations

```dart file=../../examples/lib/relations/loading.dart#eager-multiple
```

### Nested Relations

Load multiple levels of relationships using dot notation. Ormed will recursively load each segment of the path.

```dart file=../../examples/lib/relations/loading.dart#eager-nested
```

You can constrain nested segments when needed:

```dart
final posts = await dataSource.query<$Post>()
  .withRelation('comments.user', (q) => q.where('active', true))
  .get();
```

## 2. Lazy Load When Needed

Lazy loading is useful for conditional paths, but prefer eager loading in list endpoints.

### Load Relations

```dart file=../../examples/lib/relations/loading.dart#lazy-load
```

### Load Missing Only

Only loads relations that haven't been loaded yet:

```dart file=../../examples/lib/relations/loading.dart#lazy-load-missing
```

### Check If Loaded

```dart file=../../examples/lib/relations/loading.dart#check-loaded
```

## 3. Access and Manage Loaded Relations

```dart file=../../examples/lib/relations/loading.dart#relation-access
```

## 4. Load Relation Aggregates

Aggregate helpers avoid loading entire related collections.

### Count

```dart file=../../examples/lib/relations/loading.dart#relation-count
```

### Sum

```dart file=../../examples/lib/relations/loading.dart#relation-sum
```

### Other Aggregates

```dart file=../../examples/lib/relations/loading.dart#relation-other-aggregates
```

### Exists

```dart file=../../examples/lib/relations/loading.dart#relation-exists
```

## 5. Mutate Relationship Links

### Attach & Detach

```dart file=../../examples/lib/relations/loading.dart#relation-attach
```

### Sync & Toggle

```dart file=../../examples/lib/relations/loading.dart#relation-sync
```

## Belongs To Operations

```dart file=../../examples/lib/relations/loading.dart#relation-associate
```

## 6. Prevent N+1 Queries in Development

Enable lazy-loading prevention to fail fast during development:

```dart file=../../examples/lib/relations/loading.dart#prevent-n-plus-one
```

This throws when code accesses an unloaded relation, which surfaces N+1 issues early.

```dart file=../../examples/lib/relations/loading.dart#n-plus-one-bad
```

Fix by eager loading:

```dart file=../../examples/lib/relations/loading.dart#n-plus-one-good
```

## Verify Your Setup

- List endpoints eager-load the relations they render.
- Development mode catches accidental lazy loads.
- Aggregate fields (`*_count`, `*_sum`, `*_exists`) are used when full relation data is unnecessary.

## Read This Next

- [Query Builder](./query-builder)
- [Repository](./repository)
- [Model Relationships](../models/relationships)
