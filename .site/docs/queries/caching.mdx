---
sidebar_position: 5
---

# Query Caching

Query caching stores query results in memory so repeated reads can skip database round-trips.

## Prerequisites

- [Query Builder](./query-builder)
- [Repository](./repository)

## What Youâ€™ll Learn

- How to enable and tune query-level caching
- How cache invalidation and bypass options work
- When to use memory caching vs direct DB reads

## Step Outcome

By the end of this page, you should be able to cache read-heavy queries safely, inspect cache behavior, and invalidate cache on write boundaries.

## 1. Start with `remember`

Cache query results for a specified TTL:

```dart file=../../examples/lib/caching/caching.dart#cache-remember
```

How it works:
1. First query executes against the database
2. Results are stored in cache with the specified TTL
3. Equivalent subsequent queries return cached rows
4. Cache entry expires after the duration

### Use `rememberForever()` sparingly

Cache results indefinitely (until manually cleared):

```dart file=../../examples/lib/caching/caching.dart#cache-forever
```

:::warning
Use `rememberForever()` carefully! Cached data won't update automatically. Clear the cache manually when data changes.
:::

### Use `dontRemember()` to force fresh reads

Bypass the cache for a specific query:

```dart file=../../examples/lib/caching/caching.dart#cache-dont-remember
```

### Cache works with normal query chaining

```dart file=../../examples/lib/caching/caching.dart#cache-chaining
```

## 2. Manage Cache Lifecycle

### Flush all cache entries

Clear all cached queries:

```dart file=../../examples/lib/caching/caching.dart#cache-flush
```

### Vacuum expired entries

Remove expired cache entries to free memory:

```dart file=../../examples/lib/caching/caching.dart#cache-vacuum
```

### Inspect cache statistics

```dart file=../../examples/lib/caching/caching.dart#cache-stats
```

## 3. Observe Cache Behavior

Real-time notifications about cache operations:

| Event | Trigger | Properties |
|-------|---------|-----------|
| `CacheHitEvent` | Result found in cache | sql, parameters, timestamp |
| `CacheMissEvent` | Result not in cache | sql, parameters, timestamp |
| `CacheStoreEvent` | Result stored in cache | sql, parameters, ttl, rowCount |
| `CacheForgetEvent` | Entry removed | sql, parameters, timestamp |
| `CacheFlushEvent` | All cache cleared | timestamp, entriesCleared |
| `CacheVacuumEvent` | Expired entries cleaned | timestamp, entriesRemoved |

### Listen to events

```dart file=../../examples/lib/caching/caching.dart#cache-events-listening

```

### Track hit/miss trends

```dart file=../../examples/lib/caching/caching.dart#cache-monitor

```

### Integrate with metrics backends

```dart file=../../examples/lib/caching/caching.dart#cache-metrics-integration

```

## 4. Choose Good Cache Targets

Good candidates:

- Dashboard statistics and reports
- Reference data (countries, categories)
- User permissions and roles
- Popular content (trending posts)
- Aggregated data

Poor candidates:

- Real-time data requiring immediate consistency
- User-specific personalized content
- Rapidly changing data (live scores, stock prices)
- Write-heavy operations

## 5. Apply Practical Patterns

### Select TTLs by volatility

```dart file=../../examples/lib/caching/caching.dart#cache-best-practices-ttl

```

### Prioritize expensive queries

```dart file=../../examples/lib/caching/caching.dart#cache-expensive-queries

```

### Clear cache after schema/data-shape changes

```dart file=../../examples/lib/caching/caching.dart#cache-clear-on-schema

```

### Avoid global caching for user-specific data

```dart file=../../examples/lib/caching/caching.dart#cache-user-specific-bad

```

```dart file=../../examples/lib/caching/caching.dart#cache-user-specific-good

```

### Monitor Cache Performance

```dart file=../../examples/lib/caching/caching.dart#cache-performance-monitor

```

## 6. Pick an Invalidation Strategy

### Time-based (TTL)

```dart file=../../examples/lib/caching/caching.dart#cache-ttl-invalidation

```

### Manual invalidation

```dart file=../../examples/lib/caching/caching.dart#cache-manual-invalidation

```

### Event-driven invalidation

```dart file=../../examples/lib/caching/caching.dart#cache-event-driven-invalidation

```

## Verify Your Setup

- Re-running the same read query produces cache hits.
- Write paths invalidate cache intentionally (`flushQueryCache` or event-driven hook).
- Hit ratio is monitored so cache usage can be tuned over time.

## Read This Next

- [Query Builder](./query-builder)
- [Observability](../guides/observability)
- [Best Practices](../guides/best-practices)
