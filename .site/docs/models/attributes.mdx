---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Model Attributes

Ormed models support **attribute metadata** that affects:

## Prerequisites

- [Defining Models](./defining-models)
- [Quick Start](../getting-started/quick-start)

## What You’ll Learn

- How mass-assignment rules (`fillable`, `guarded`) are enforced
- How visibility (`hidden`, `visible`) affects serialization
- How attribute metadata connects to casting behavior

## Step Outcome

By the end of this page, you should be able to:

- Safely accept trusted/untrusted input with `fill` vs `forceFill`
- Control serialized output fields for API/web responses
- Use accessors/mutators without breaking tracked model behavior

- Mass assignment (`fill`, `fillIfAbsent`, `forceFill`)
- Serialization (`toArray`, `toJson`)
- Casting (see **Models → Casting**)

:::note Tracked models
These APIs are designed for tracked models (the generated `$Model` types) and instances returned by queries. Plain user-defined model instances are immutable and typically not used for mass assignment.
:::

## Define metadata

Attribute metadata can be declared at the model level, and optionally overridden per-field.

```dart file=../../examples/lib/models/attribute_metadata_examples.dart#attributes-model-level
```

## Mass assignment

Mass assignment takes a `Map<String, Object?>` keyed by **column names** and applies `fillable`/`guarded` rules.

```dart file=../../examples/lib/models/attribute_metadata_examples.dart#attributes-fill
```

Notes:
- `fill(...)` defaults to `strict: false` (guarded keys are discarded).
- Set `strict: true` to throw a `MassAssignmentException` when a guarded key is present.
- Use `forceFill(...)` only for trusted/internal flows.
- `fill` / `fillIfAbsent` / `forceFill` accept tracked models, DTOs, and partials in addition to maps.
- Map keys can be Dart field names or column names (they are normalized).

Default to `fill(...)` for request payloads, and reserve `forceFill(...)` for trusted internal flows.

## Serialization (hidden / visible)

`toArray()` / `toJson()` honor `hidden` by default. To include hidden values you must set `includeHidden: true`, and the column must also be listed in `visible`.

```dart file=../../examples/lib/models/attribute_metadata_examples.dart#attributes-serialize
```

Keep sensitive values (`password`, secrets, tokens) hidden by default, even for internal APIs.

## Accessors and mutators

Accessors let you transform attribute reads, while mutators normalize values when they are assigned.
Define them as static members on the model, similar to query scopes.

```dart file=../../examples/lib/models/attribute_metadata_examples.dart#attributes-accessors
```

:::note Static-only accessors
Accessors and mutators must be declared as `static`. The generator exposes them
on tracked models via extensions, so you can read `tracked.displayName` and call
`tracked.normalizeEmail('User@Example.com')`. Accessors apply when using
`getAttribute(...)` and serialization (`toArray`, `toJson`). Mutators apply when
using `setAttribute(...)`, `fill(...)`, or tracked setters. Use
`getRawAttribute(...)` / `setRawAttribute(...)` to bypass accessors/mutators.
:::

## Appends (computed attributes)

Use `appends` to include computed attributes in `toArray()` / `toJson()` output.

```dart file=../../examples/lib/models/attribute_metadata_examples.dart#attributes-appends
```

## Verify Attribute Rules

Add tests for:

1. Guarded key rejection/ignore behavior.
2. Hidden/visible serialization output.
3. Accessor/mutator behavior on tracked instances.

## Read This Next

- [Casting](./casting)
- [Model Scopes](./scopes)
- [Query Builder](../queries/query-builder)
