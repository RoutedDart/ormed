---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Relationships

Ormed supports common relationship types between models using the `@OrmRelation` annotation.

## Prerequisites

- [Defining Models](./defining-models)
- [Query Builder](../queries/query-builder)

## What Youâ€™ll Learn

- How to declare each relation type with `@OrmRelation`
- How relation metadata drives eager and lazy loading
- How to avoid common relation loading pitfalls

## Relationship Types

<Tabs groupId="relationship-types" defaultValue="has-one">
  <TabItem value="has-one" label="Has One">

A one-to-one relationship where the related model has the foreign key.

```dart file=../../examples/lib/models/relations/has_one.dart#relation-has-one
```

  </TabItem>
  <TabItem value="has-many" label="Has Many">

A one-to-many relationship.

```dart file=../../examples/lib/models/relations/has_many.dart#relation-has-many
```

  </TabItem>
  <TabItem value="has-many-through" label="Has Many Through">

Load related models through an intermediate model.

```dart file=../../examples/lib/models/relations/has_many_through.dart#relation-has-many-through
```

  </TabItem>
  <TabItem value="belongs-to" label="Belongs To">

The inverse of hasOne/hasMany: this model owns the foreign key.

```dart file=../../examples/lib/models/relations/belongs_to.dart#relation-belongs-to-post
```

```dart file=../../examples/lib/models/relations/belongs_to.dart#relation-belongs-to-author
```

  </TabItem>
  <TabItem value="belongs-to-many" label="Belongs To Many">

A many-to-many relationship using a pivot table. Ormed automatically handles the pivot table joins for efficient querying.

```dart file=../../examples/lib/models/relations/belongs_to_many.dart#relation-belongs-to-many-post
```

```dart file=../../examples/lib/models/relations/belongs_to_many.dart#relation-belongs-to-many-tag
```

Use `withPivot` to include pivot columns when loading the related models. The
selected pivot values are attached as a `pivot` relation on each related model.

```dart file=../../examples/lib/models/relations/belongs_to_many.dart#relation-belongs-to-many-pivot
```

```dart
final pivot = tag.getRelation<Map<String, Object?>>('pivot');
final sortOrder = pivot?['sort_order'];
```

  </TabItem>
</Tabs>

## Polymorphic Relationships

Polymorphic relationships let a model belong to more than one type of model on
a single association.

<Tabs groupId="relationship-types-polymorphic" defaultValue="morph-one">
  <TabItem value="morph-one" label="Morph One">

```dart file=../../examples/lib/models/relations/polymorphic.dart#relation-morph-one
```

  </TabItem>
  <TabItem value="morph-many" label="Morph Many">

```dart file=../../examples/lib/models/relations/polymorphic.dart#relation-morph-many
```

  </TabItem>
  <TabItem value="morph-to" label="Morph To">

```dart file=../../examples/lib/models/relations/polymorphic.dart#relation-morph-to
```

  </TabItem>
  <TabItem value="morph-to-many" label="Morph To Many">

```dart file=../../examples/lib/models/relations/polymorphic.dart#relation-morph-to-many
```

  </TabItem>
  <TabItem value="morphed-by-many" label="Morphed By Many">

```dart file=../../examples/lib/models/relations/polymorphic.dart#relation-morphed-by-many
```

  </TabItem>
</Tabs>

:::note Morph-to constraints
`morphTo` relations do not support constraint callbacks and cannot be used as
intermediate segments in nested relation paths. Use `morphTo` as the final
segment when eager loading.
:::

### Morph Map Aliases

If your morph types store aliases instead of full model names, register a map
before loading relations:

```dart
dataSource.registry.registerMorphMap({
  'post': Post,
  'user': User,
});
```

## Loading Relations

### Eager Loading

Load relations upfront with the query:

<Tabs groupId="relation-loading-eager" defaultValue="basic">
  <TabItem value="basic" label="Basic">

```dart file=../../examples/lib/relations/loading.dart#eager-basic
```

  </TabItem>
  <TabItem value="multiple" label="Multiple">

```dart file=../../examples/lib/relations/loading.dart#eager-multiple
```

  </TabItem>
  <TabItem value="nested" label="Nested">

```dart file=../../examples/lib/relations/loading.dart#eager-nested
```

  </TabItem>
</Tabs>

### Lazy Loading

Load relations on-demand:

<Tabs groupId="relation-loading-lazy" defaultValue="load">
  <TabItem value="load" label="Load">

```dart file=../../examples/lib/relations/loading.dart#lazy-load
```

  </TabItem>
  <TabItem value="missing" label="Missing">

```dart file=../../examples/lib/relations/loading.dart#lazy-load-missing
```

  </TabItem>
</Tabs>

### Checking Relation Status

```dart file=../../examples/lib/relations/loading.dart#check-loaded
```

## Touching Related Models

To automatically update related models' `updated_at` when this model changes,
declare the relations to touch:

```dart
@OrmModel(touches: ['author', 'tags'])
class Post extends Model<Post> with Timestamps {
  @OrmRelation.belongsTo(target: User, foreignKey: 'author_id')
  User? author;

  @OrmRelation.belongsToMany(target: Tag, through: 'post_tags')
  List<Tag>? tags;
}
```

When a touched model is saved or deleted, Ormed updates the related models'
`updated_at` (for belongs-to, has-one/has-many, and many-to-many relations).

Manual control is also available:

```dart
await post.touch(); // update this model's updated_at
await post.touchOwners(); // update touched relations
```

:::note Touching requires timestamps
Only models with timestamps enabled (and an `updated_at` column) are touched.
:::

To suppress touching within a scope:

```dart
await Model.withoutTouchingOn(<Type>[Post], () async {
  await post.save();
});
```

## Relation Manipulation

### Setting Relations

```dart file=../../examples/lib/relations/loading.dart#relation-associate
```

### Creating Related Models

Create new related models through a parent model's hasMany/hasOne relationship:

<Tabs groupId="relation-create" defaultValue="basic">
  <TabItem value="basic" label="Basic">

```dart file=../../examples/lib/relations/mutations.dart#create-relation-basic
```

  </TabItem>
  <TabItem value="dto" label="With DTOs">

Use type-safe DTOs instead of raw maps:

```dart file=../../examples/lib/relations/mutations.dart#create-relation-dto
```

  </TabItem>
  <TabItem value="many" label="Create Many">

Create multiple related models at once:

```dart file=../../examples/lib/relations/mutations.dart#create-many-relation
```

  </TabItem>
  <TabItem value="mixed" label="Mixed Input Types">

Mix different input types in a single call:

```dart file=../../examples/lib/relations/mutations.dart#create-many-relation-mixed
```

  </TabItem>
</Tabs>

### Event-Suppressed Creation

Create related models without triggering lifecycle events:

<Tabs groupId="relation-create-quietly" defaultValue="single">
  <TabItem value="single" label="Single">

```dart file=../../examples/lib/relations/mutations.dart#create-quietly-relation
```

  </TabItem>
  <TabItem value="many" label="Many">

```dart file=../../examples/lib/relations/mutations.dart#create-many-quietly-relation
```

  </TabItem>
</Tabs>

### Many-to-Many Operations

<Tabs groupId="relation-many-to-many" defaultValue="attach">
  <TabItem value="attach" label="Attach">

```dart file=../../examples/lib/relations/loading.dart#relation-attach
```

  </TabItem>
  <TabItem value="sync" label="Sync">

```dart file=../../examples/lib/relations/loading.dart#relation-sync
```

  </TabItem>
</Tabs>

## Aggregate Loading

Load aggregate values without fetching all related models:

<Tabs groupId="relation-aggregates" defaultValue="count">
  <TabItem value="count" label="Count">

```dart file=../../examples/lib/relations/loading.dart#relation-count
```

  </TabItem>
  <TabItem value="sum" label="Sum">

```dart file=../../examples/lib/relations/loading.dart#relation-sum
```

  </TabItem>
  <TabItem value="exists" label="Exists">

```dart file=../../examples/lib/relations/loading.dart#relation-exists
```

  </TabItem>
</Tabs>

## Preventing N+1 Queries

Use `Model.preventLazyLoading()` in development to catch N+1 issues:

```dart file=../../examples/lib/relations/loading.dart#prevent-n-plus-one
```

This throws an exception when accessing relations that haven't been eager-loaded, helping you identify performance issues early.

## Read This Next

- [Loading Relations](../queries/relations)
- [Query Builder](../queries/query-builder)
- [Repository](../queries/repository)
