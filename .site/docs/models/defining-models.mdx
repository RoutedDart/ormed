---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Defining Models

Models in Ormed are Dart classes annotated with `@OrmModel` that map to database tables.

## Prerequisites

- You completed [Quick Start](../getting-started/quick-start)
- You understand runtime setup from [Configuration](../getting-started/configuration)

## What You’ll Learn

- How to design model classes and field mappings
- Which generated artifacts each model produces
- How to prepare models for querying, relations, and migrations

## Step Outcome

By the end of this page, you should have:

- At least one annotated model that compiles
- Generated `*.orm.dart` artifacts for that model
- A clear mapping between class fields and DB columns

## Naming Conventions

By default, Ormed follows standard database naming conventions:

- **Tables**: Pluralized `snake_case` version of the class name.
  - `User` → `users`
  - `UserRole` → `user_roles`
- **Columns**: `snake_case` version of the field name.
  - `emailAddress` → `email_address`
  - `createdAt` → `created_at`

You can override these defaults using the `table` property on `@OrmModel` and the `columnName` property on `@OrmField`.

Use defaults unless you are mapping to an existing schema or a strict naming standard.

:::note Snippet context
- Snippets show model definitions and generated usage in isolation.
- Run `dart run build_runner build` after creating/updating models to generate `$Model`, `OrmDefinition`, and DTOs.
:::

## Basic Model

```dart file=../../examples/lib/models/user.dart#basic-model

```

After running `dart run build_runner build`, this generates:
- `$User` - Tracked model class with change tracking
- `UserOrmDefinition` - Model metadata and static helpers
- `$UserPartial` - Partial entity for projections
- `UserInsertDto` / `UserUpdateDto` - Data transfer objects

## Model Definition Checklist

- Primary key field is explicit.
- Optional DB columns use nullable Dart types.
- Non-column relation fields are marked `@OrmField(ignore: true)`.
- Table/column overrides are only added where needed.

## Model Annotation Options

<Tabs groupId="model-annotation-options" defaultValue="notes">
  <TabItem value="notes" label="Notes">

Use options to control table naming, timestamps, touches, soft deletes, and other model-level behavior.

Key options include:
<ul>
  <li>
    <code>timestamps</code>: enable/disable automatic <code>created_at</code> / <code>updated_at</code> updates
  </li>
  <li>
    <code>touches</code>: relation names to touch (update <code>updated_at</code>) when this model changes
  </li>
</ul>

  </TabItem>
  <TabItem value="example" label="Example">

```dart file=../../examples/lib/models/admin.dart#model-with-options

```

  </TabItem>
</Tabs>

## Attribute metadata (fillable/guarded/hidden/visible/casts)

Ormed can enforce mass-assignment rules and control what gets serialized.

<Tabs groupId="attribute-metadata" defaultValue="notes">
  <TabItem value="notes" label="Notes">

<ul>
  <li>
    <code>fillable</code> / <code>guarded</code> are used by <code>model.fill(...)</code> and <code>model.forceFill(...)</code>.
  </li>
  <li>
    <code>hidden</code> / <code>visible</code> affect <code>model.toArray()</code> / <code>model.toJson()</code>.
  </li>
  <li>
    <code>casts</code> / <code>@OrmField(cast: ...)</code> pick codecs for database + serialization.
  </li>
</ul>

  </TabItem>
  <TabItem value="casts" label="Casts">

See **Models → Model Attributes** (mass assignment + serialization) and **Models → Casting** (casts + custom codecs).

  </TabItem>
</Tabs>

## Field Annotations

### Primary Key

<Tabs groupId="model-primary-keys" defaultValue="notes">
  <TabItem value="notes" label="Notes">

Primary key configuration affects inserts, updates, and how models are identified when syncing relations.

  </TabItem>
  <TabItem value="examples" label="Examples">

```dart file=../../examples/lib/models/field_examples.dart#primary-key-examples

```

  </TabItem>
</Tabs>

### Column Options

```dart file=../../examples/lib/models/field_examples.dart#column-options

```

### Custom Codecs

For complex types, use value codecs:

```dart file=../../examples/lib/generated_code_usage.dart#custom-codecs-field

```

## Generated Code

### Tracked Model (`$User`)

The generated `$User` class is the "tracked" version of your model with:
- Change tracking for dirty fields
- Relationship accessors
- Model lifecycle methods

```dart file=../../examples/lib/generated_code_usage.dart#tracked-model-usage

```

### Definition (`UserOrmDefinition`)

Provides static helpers and model metadata:

```dart file=../../examples/lib/generated_code_usage.dart#definition-usage

```

### Partial Entity (`$UserPartial`)

For projecting specific columns:

```dart file=../../examples/lib/generated_code_usage.dart#partial-entity-usage

```

### DTOs

Data transfer objects for insert/update operations:

```dart file=../../examples/lib/generated_code_usage.dart#dto-usage

```

## Best Practices

1. **Use const constructors** - Helps with immutability and tree-shaking
2. **Define all fields as final** - Models are immutable by design
3. **Use nullable types** for optional fields - Clearer intent
4. **Keep models focused** - One model per table
5. **Use DTOs** for partial updates - More explicit than tracked models

## Verify Before Continuing

```bash
dart run build_runner build --delete-conflicting-outputs
dart analyze
```

You should see generated `*.orm.dart` files and no generation-related analyzer errors.

## Read This Next

- [Model Attributes](./attributes)
- [Relationships](./relationships)
- [Query Builder](../queries/query-builder)
