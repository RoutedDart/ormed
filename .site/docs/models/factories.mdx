---
sidebar_position: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Model Factories

Model factories provide a convenient way to generate test data for your ORM models with deterministic seeding, field overrides, and persistence integration.

## Quick Start

```dart file=../../examples/lib/factories/basic.dart#factory-quickstart

```

## Enabling Factory Support

Add `ModelFactoryCapable` mixin to your model:

```dart file=../../examples/lib/models/factory_user.dart#factory-capable-model

```

The generator detects `ModelFactoryCapable` anywhere in the inheritance chain.

### Inheritance Support

```dart file=../../examples/lib/models/factory_inheritance.dart#factory-inheritance

```

## External Factory Classes

Define factories in their own class to keep defaults, states, and hooks in a
single place:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-definition

```

### When to Use External Factories

Use external factories when:
- **Reusing across tests**: The factory is used in multiple test files
- **Complex defaults**: The factory has many fields or complex initialization logic
- **Multiple variants**: You need several named states (admin, pending, completed, etc.)
- **Factory hooks**: You need `afterMaking()` or `afterCreating()` callbacks
- **Project-wide consistency**: You want standardized defaults across your test suite

Register the external factory before using it:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-registration

```

Then use `Model.factory()` as usual:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-usage

```

Named states can be applied through the factory definition:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-state

```

## Advanced External Factory Patterns

### Factory Hooks and Configuration

Configure callbacks directly in your factory definition using the `configure()` method:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-with-hooks

```

This keeps all factory logic in one place, making it easier to understand and maintain factory behavior.

### Multiple States and Variants

Define named states for different model variations:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-multiple-states

```

This is more maintainable than passing complex override maps repeatedly in tests.

### Factory Composition and Inheritance

Create specialized factories that inherit from base factories:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-composition

```

This prevents duplication and ensures consistency across related factory definitions.

### Custom Field Generators

Override field generation logic for specific scenarios:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-custom-generator

```

### Project Organization

Keep factories organized and easy to discover:

```dart file=../../examples/lib/factories/external_factory.dart#factory-external-organization

```

Benefits:
- **Consistency**: All factories follow the same patterns
- **Maintainability**: Easy to update defaults across tests
- **Discoverability**: Related factories grouped together
- **Isolation**: Factories don't pollute model files

## Factory Builder API

| Method | Description |
|--------|-------------|
| `values()` | Returns the generated column map |
| `value(field)` | Returns a single generated value |
| `make({registry})` | Creates a model instance without persisting |
| `makeMany({registry})` | Creates multiple model instances without persisting |
| `create({context, returning})` | Creates and persists the model |
| `createMany({context, returning})` | Creates and persists multiple models |
| `withOverrides(map)` | Sets multiple field overrides |
| `withField(field, value)` | Sets a single field override |
| `withGenerator(field, fn)` | Replaces the generator for a field |
| `seed(int)` | Sets deterministic seed for reproducibility |
| `reset()` | Clears generated values for fresh generation |
| `count(n)` | Sets number of models to create with `makeMany`/`createMany` |
| `state(map)` | Applies a state transformation |
| `stateUsing(fn)` | Applies a closure-based state transformation |
| `sequence([...])` | Cycles attribute sets across batch creation |
| `sequenceUsing(fn)` | Generates attributes based on index |
| `afterMaking(fn)` | Registers callback after `make()` |
| `afterCreating(fn)` | Registers callback after `create()` |
| `trashed([timestamp])` | Marks model as soft-deleted |

## Field Overrides

Override specific fields while letting others be generated:

```dart file=../../examples/lib/factories/basic.dart#factory-field-overrides

```

## Deterministic Seeding

Use seeds for reproducible test data:

```dart file=../../examples/lib/factories/basic.dart#factory-seeding

```

## Batch Creation

Create multiple models at once using `count()`:

```dart file=../../examples/lib/factories/basic.dart#factory-batch

```

## State Transformations

Apply named state modifications to models:

```dart file=../../examples/lib/factories/basic.dart#factory-states

```

## Sequences

Cycle through attribute values when creating multiple models:

```dart file=../../examples/lib/factories/basic.dart#factory-sequences

```

## Callbacks

Execute code after models are made or created:

<Tabs groupId="factory-callbacks" defaultValue="afterMaking">
  <TabItem value="afterMaking" label="afterMaking">

Runs after `make()` (sync).

```dart file=../../examples/lib/factories/basic.dart#factory-callbacks-afterMaking
```

  </TabItem>
  <TabItem value="afterCreating" label="afterCreating">

Runs after `create()` (async).

```dart file=../../examples/lib/factories/basic.dart#factory-callbacks-afterCreating
```

  </TabItem>
  <TabItem value="chain" label="Chaining">

Callbacks can be chained and run in registration order.

```dart file=../../examples/lib/factories/basic.dart#factory-callbacks-chain
```

  </TabItem>
</Tabs>

## Soft-Deleted Models

Create models that are already soft-deleted:

```dart file=../../examples/lib/factories/basic.dart#factory-trashed

```

## Custom Field Generators

Replace the default generator for specific fields:

```dart file=../../examples/lib/factories/basic.dart#factory-custom-generators

```

### Carbon/CarbonInterface Fields

For models using `Carbon` or `CarbonInterface` fields, the factory automatically generates appropriate values:

```dart file=../../examples/lib/factories/basic.dart#factory-carbon-fields

```

## Default Value Generation

The `DefaultFieldGeneratorProvider` generates values based on field types:

| Type | Generated Value |
|------|-----------------|
| `int` | Random 1-1000 |
| `double`, `num` | Random 0-1000.0 |
| `bool` | Random true/false |
| `String` | `"ModelName_fieldName_XXXX"` |
| `DateTime` | Now + random seconds (0-86400) |
| `Carbon`, `CarbonInterface` | `Carbon.now()` + random seconds (0-86400) |
| `Map<K,V>` | Empty map `{}` |
| `List<T>` | Empty list `[]` |
| Nullable types | 50% chance of `null` |

Auto-increment fields and fields with `defaultValueSql` are skipped unless explicitly overridden.

## Custom Generator Providers

Create a custom provider for specialized data generation:

<Tabs groupId="factory-custom-provider" defaultValue="notes">
  <TabItem value="notes" label="Notes">

Use custom providers when a field needs deterministic or domain-specific behavior (hashing, UUIDs, time, etc.).

  </TabItem>
  <TabItem value="code" label="Code">

```dart file=../../examples/lib/factories/basic.dart#factory-custom-provider

```

  </TabItem>
</Tabs>

## Testing Patterns

### Seeded Tests for Reproducibility

```dart file=../../examples/lib/factories/basic.dart#factory-seeded-test

```

### Factory Helpers for Common Scenarios

```dart file=../../examples/lib/factories/basic.dart#factory-helpers

```

### Cross-Model References

```dart file=../../examples/lib/factories/basic.dart#factory-cross-model

```

### Batch Generation

```dart file=../../examples/lib/factories/basic.dart#factory-batch-generation

```

## Connection-Bound Helpers

Use `withConnection` to get query and repository access:

```dart file=../../examples/lib/factories/basic.dart#factory-connection-bound

```

## Best Practices

### 1. Keep Factories Simple

Factories should generate valid, realistic data. Complex logic belongs in application code, not factories:

```dart
// ❌ Avoid: Complex business logic
class OrderFactory extends ModelFactoryDefinition<Order> {
  @override
  void configure(ModelFactoryBuilder<Order> builder) {
    builder.afterCreating((order) async {
      // Don't put business logic here
      await calculateTax(order);
      await checkInventory(order);
    });
  }
}

// ✅ Good: Just set realistic defaults
class OrderFactory extends ModelFactoryDefinition<Order> {
  @override
  Map<String, Object?> defaults() => {
    'status': 'pending',
    'total': 100.0,
    'tax': 15.0,
  };
}
```

### 2. Use States for Variations

Instead of creating multiple factories, use states for variations of the same model:

```dart
// ❌ Avoid: Multiple nearly-identical factories
class PendingOrderFactory extends ModelFactoryDefinition<Order> {
  @override
  Map<String, Object?> defaults() => {'status': 'pending'};
}

class CompletedOrderFactory extends ModelFactoryDefinition<Order> {
  @override
  Map<String, Object?> defaults() => {'status': 'completed'};
}

// ✅ Good: One factory with multiple states
class OrderFactory extends ModelFactoryDefinition<Order> {
  @override
  Map<String, Object?> defaults() => {'status': 'pending'};

  @override
  Map<String, StateTransformer<Order>> get states => {
    'completed': (attrs) => {'status': 'completed'},
    'cancelled': (attrs) => {'status': 'cancelled'},
  };
}
```

### 3. Preserve Referential Integrity

When creating models with relationships, ensure foreign keys are valid:

```dart
// ✅ Good: Create related models
await ormedTest('creates post with valid user_id', (fixture) async {
  final user = await FactoryUser.factory().create();
  final post = await FactoryPost.factory()
    .withField('user_id', user.id)
    .create();
  expect(post.userId, equals(user.id));
});
```

### 4. Use Seeds for Debugging

When a test fails non-deterministically, seed the factory to reproduce it:

```dart
// First run: fails randomly
final user = FactoryUser.factory().make();

// Second run: fix the seed to reproduce the failure
final user = FactoryUser.factory().seed(12345).make();
```

### 5. Separate Fixture Setup

Extract repeated factory patterns into helper methods:

```dart
Future<(FactoryUser, List<FactoryPost>)> createUserWithPosts(int count) async {
  final user = await FactoryUser.factory().create();
  final posts = await FactoryPost.factory()
    .withField('user_id', user.id)
    .count(count)
    .create();
  return (user, posts);
}

// Usage in tests:
await ormedTest('user has 5 posts', (fixture) async {
  final (user, posts) = await createUserWithPosts(5);
  expect(user.posts, hasLength(5));
});
```

### 6. Override Only What Matters

Keep test intent clear by only overriding fields relevant to what you're testing:

```dart
// ❌ Unclear: Sets many fields unrelated to test
final user = await FactoryUser.factory()
  .withField('name', 'John')
  .withField('email', 'john@test.com')
  .withField('status', 'active')
  .withField('created_at', DateTime.now())
  .create();

// ✅ Clear: Only override what the test cares about
final user = await FactoryUser.factory()
  .withField('email', 'john@test.com')
  .create();
```
