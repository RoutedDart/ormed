# Update

The `update` function is where your application's logic lives. it's responsible for taking an incoming `Msg` and the current `Model`, and returning a new `Model` and an optional `Cmd`.

## The Update Signature

```dart
(Model, Cmd?) update(Msg msg)
```

## Handling Messages

Typically, you'll use a `switch` statement or `if` checks to handle different types of messages:

```dart
@override
(Model, Cmd?) update(Msg msg) {
  return switch (msg) {
    KeyMsg(key: Key(type: KeyType.up)) => (CounterModel(count + 1), null),
    KeyMsg(key: Key(type: KeyType.down)) => (CounterModel(count - 1), null),
    _ => (this, null),
  };
}
```

## Returning Commands

If an update needs to perform an asynchronous operation (like fetching data or starting a timer), it returns a `Cmd`.

```dart
@override
(Model, Cmd?) update(Msg msg) {
  if (msg is FetchDataMsg) {
    return (this, fetchDataCmd());
  }
  return (this, null);
}
```

## Side Effects

The `update` function should be a **pure function**. It should not perform any side effects directly (like printing to the console or making network requests). Instead, it should describe those side effects by returning a `Cmd`.
