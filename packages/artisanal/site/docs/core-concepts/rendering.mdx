# Rendering Architecture

Artisanal features a two-tier rendering architecture designed to handle everything from simple CLI logging to high-performance, full-screen TUI applications.

## The Two Layers

The system is divided into a high-level stateless layer and a low-level stateful engine.

| Feature | High-Level `Renderer` | Low-Level `UV` Renderer |
| :--- | :--- | :--- |
| **Primary Use** | Standard CLI output, logging, simple styling. | Full-screen interactive TUIs. |
| **Model** | Stream-based (immediate write). | Buffer-based (grid of cells). |
| **State** | Stateless. | Stateful (tracks screen state). |
| **Efficiency** | Simple, direct. | High (diffing, minimal ANSI). |
| **Performance** | N/A | FPS, Frame timing, Scroll optimization. |
| **Integration** | Used by `Console` and `Style`. | Used by `Program` (TEA runtime). |

---

## High-Level Renderer

The high-level `Renderer` interface provides a stateless abstraction for writing styled text. It is primarily used by the `Console` class and the `Style` system.

### Key Features

- **Color Downsampling**: Automatically detects terminal capabilities (TrueColor, ANSI256, ANSI) and downsamples colors to the best available match.
- **Multiple Targets**: Includes implementations for `TerminalRenderer` (stdout), `StringRenderer` (capturing to a string), and `NullRenderer`.

### Example Usage

```dart file=../../../example/doc_examples.dart#renderer_usage_example
```

---

## TUI Renderers (TEA)

When building interactive applications with the `Program` class, you use a `TuiRenderer`. These are stateful renderers that manage the terminal screen over time.

### Built-in TUI Renderers

- **`UltravioletTuiRenderer` (Default)**: The most advanced renderer. It uses the UV engine to perform buffer diffing and minimal ANSI updates.
- **`FullScreenTuiRenderer`**: A simpler fullscreen renderer that clears the screen and redraws everything on every frame.
- **`InlineTuiRenderer`**: Renders the UI "inline" (below the current cursor position) rather than taking over the whole screen. It clears only the lines it previously wrote.
- **`StringSinkTuiRenderer`**: Useful for testing or capturing the output of a TUI application into a string.

### Choosing a Renderer

You can specify the renderer in `ProgramOptions`:

```dart file=../../../example/doc_examples.dart#tui_renderer_options_example
```

---

## Low-Level UV Renderer (Ultraviolet)

The `UvTerminalRenderer` is a high-performance "game engine" style renderer that powers the Bubble Tea runtime.

### How it Works

Unlike traditional TUI rendering which often repaints the entire screen, UV maintains a "current" and "next" buffer of terminal cells. When a frame is rendered, UV:

1.  **Diffs the Buffers**: Identifies exactly which cells have changed.
2.  **Optimizes Movement**: Calculates the most efficient ANSI sequences to update only the changed cells.
3.  **Scroll Optimization**: Detects when lines have been shifted and uses terminal scrolling commands to move existing content.

### Performance Metrics

The UV renderer tracks detailed performance metrics, allowing you to monitor the health of your TUI application.

```dart file=../../../example/doc_examples.dart#uv_metrics_example
```

### UV by Default

The Ultraviolet renderer and input decoder are enabled by default for all `Program` based applications.

```dart file=../../../example/doc_examples.dart#enabling_uv_example
```

---

## Full Examples

For complete examples of both rendering styles, check out the following:

- **Standard CLI Output**: See the `DemoCommand` in [example/main.dart](../../../example/main.dart).
- **Interactive TUI**: See the `UiAllCommand` in [example/main.dart](../../../example/main.dart) which uses the full TEA runtime and UV engine.

For more advanced UV features, see the [Advanced Rendering](../advanced-rendering/overview.mdx) section.
